FROM docker.io/golang:1.24.3-alpine AS builder

RUN apk add --no-cache \
    build-base \
    musl-dev \
    pkgconfig \
    vips-dev \
    vips-tools \
    glib-dev

WORKDIR /src

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN set -x && \
    cd healthcheck-app && \
    make

ARG BUILD_VERSION

ENV CGO_ENABLED=1
ENV GOOS=linux
ENV GOARCH=amd64

RUN set -x && \
    go build -a -ldflags="-X main.buildVersion=HEAD -s -w" \
    -o /app/robohash ./cmd/server

FROM alpine:latest

RUN apk add --no-cache \
    vips \
    vips-tools

WORKDIR /app

COPY --from=builder /src/healthcheck-app/healthcheck /bin/healthcheck

COPY --from=builder /app/robohash .

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/bin/healthcheck", "http://localhost:8080/health"]

LABEL org.opencontainers.image.title="Robohash" \
      org.opencontainers.image.description="Robohash generator Golang implementation" \
      org.opencontainers.image.authors="terem42" \
      org.opencontainers.image.url="https://github.com/terem42/robohash" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.vendor="terem42"

ENTRYPOINT ["/app/robohash"]---------------------
github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davidbyttow/govips/v2 v2.16.0 h1:1nH/Rbx8qZP1hd+oYL9fYQjAnm1+KorX9s07ZGseQmo=
github.com/davidbyttow/govips/v2 v2.16.0/go.mod h1:clH5/IDVmG5eVyc23qYpyi7kmOT0B/1QNTKtci4RkyM=
github.com/facette/natsort v0.0.0-20181210072756-2cd4dd1e2dcb h1:IT4JYU7k4ikYg1SCxNI1/Tieq/NFvh6dzLdgi7eu0tM=
github.com/facette/natsort v0.0.0-20181210072756-2cd4dd1e2dcb/go.mod h1:bH6Xx7IW64qjjJq8M2u4dxNaBiDfKK+z/3eGDpXEQhc=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=
golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
golang.org/x/image v0.18.0/go.mod h1:4yyo5vMFQjVjUcVk4jEQcU9MGy/rulF5WvUILseCM2E=
golang.org/x/image v0.27.0 h1:C8gA4oWU/tKkdCfYT6T2u4faJu3MeNS5O8UPWlPF61w=
golang.org/x/image v0.27.0/go.mod h1:xbdrClrAUway1MUTEZDq9mz/UpRwYAkFFNUslZtcB+g=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=
golang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=
golang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=
golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=
golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=
golang.org/x/text v0.25.0 h1:qVyWApTSYLk/drJRO5mDlNYskwQznZmkpV2c8q9zls4=
golang.org/x/text v0.25.0/go.mod h1:WEdwpYrmk1qmdHvhkSTNPm3app7v4rsT8F2UD6+VHIA=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20200902074654-038fdea0a05b/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
---------------------
# Robohash for Golang

[![Go Report Card](https://goreportcard.com/badge/github.com/terem42/robohash)](https://goreportcard.com/report/github.com/terem42/robohash)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A Golang implementation of Robohash, the awesome library for generating unique robot/avatar images from any text hash. This is a port of the original [Robohash](https://github.com/e1ven/Robohash) project with performance improvements and additional features, such as performance improvements, image caching and AVIF/WebP support

Alllows image returned being encoded either PNG, lossless WEBP or AVIF. PNG format is used by default, AVIF or WEBP when either .avif or .webp extensions are supplied

Available as a module or standalone HTTP server.

**Note**: This project uses the original image assets from Robohash under their [original license](https://github.com/e1ven/Robohash/blob/master/LICENSE).

## Features

- ğŸš€ High-performance image generation (5-10x faster than original Python version)
- ğŸ–¼ï¸ Supports all 5 original sets: Robots, Monsters, Heads, Cats, and Human Avatars
- ğŸ¨ Customizable size, background, and set selection
- âš¡ Built with Go's standard libraries (no external image processing dependencies)
- ğŸ³ Docker-ready for easy deployment

## Installation

```bash
go get github.com/terem42/robohash
```

Or using Docker for standalone HTTP server version:

```bash
docker pull ghcr.io/terem42/robohash
docker run -p 8080:8080 ghcr.io/terem42/robohash
```

## Usage

### Basic URL Format

```
http://yourserver.com/{TEXT}.png?{PARAMETERS}
http://yourserver.com/{TEXT}.avif?{PARAMETERS}
```

### Examples

1. **Simple robot avatar**:
   ```
   https://robohash.yourserver.com/alice.png
   ```

2. **Monster avatar with custom size**:
   ```
   https://robohash.yourserver.com/bob.png?set=set2&size=200x200
   ```

3. **Robot head with blue background**:
   ```
   https://robohash.yourserver.com/charlie.png?set=set3&bgset=bg1
   ```

4. **Human avatar**:
   ```
   https://robohash.yourserver.com/dave@email.com.png?set=set5
   ```

5. **Human avatar encoded as AVIF**:
   ```
   https://robohash.yourserver.com/dave@email.com.avif?set=set5
   ```   
6. **Human avatar encoded as WEBP**:
   ```
   https://robohash.yourserver.com/dave@email.com.webp?set=set5
   ```   


### Available Parameters

| Parameter | Values | Description |
|-----------|--------|-------------|
| `set`     | set1, set2, set3, set4, set5 | Image set to use (default: set1) |
| `size`    | {width}x{height} | Output dimensions (e.g., 300x300) |
| `bgset`   | bg1, bg2 | Background set (only for sets 1-3) |

## Sets Overview

1. **Set1 (Robots)** - 300Ã—300px  
   Colorful robot avatars with multiple parts
   ```
   /text.png?set=set1
   ```

2. **Set2 (Monsters)** - 350Ã—350px  
   Scary monster illustrations
   ```
   /text.png?set=set2&bgset=bg1
   ```

3. **Set3 (Heads)** - 1015Ã—1015px  
   Detailed robot heads (white background recommended)
   ```
   /text.png?set=set3&size=500x500
   ```

4. **Set4 (Cats)** - 1024Ã—1024px  
   Adorable cat avatars
   ```
   /text.png?set=set4
   ```

5. **Set5 (Humans)** - 1024Ã—1024px  
   Diverse human avatars with clothing options
   ```
   /text.png?set=set5
   ```

## API Integration

```go
package main

import (
	"github.com/terem42/robohash/robohash"
)

func main() {
	// Create a new Robohash instance
	rh := robohash.NewRoboHash("alice", robohash.Set3)
	
	// Generate image
	img, err := rh.Generate()
	if err != nil {
		panic(err)
	}
	
   // rest of the code
}
```

## HTTP Caching Headers

The server automatically adds optimal caching headers for generated images  
Content-Type is set, depending on returned image  
Example for PNG images

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=31536000
ETag: "a1b2c3d4e5f6..."
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
Content-Type: image/png
Content-Length: 24872
```

## Decoded PNG assets cache

to significantly speed up image generation, package uses internal PNG assets image memory caching, both original and resized

  - Stores parsed source images in memory
  - LRU eviction policy
  - Key format: `path|widthxheight` (e.g. `assets/set1/blue/003#01Body/5.png|300x300`)

The cache size can be configured using environment variables

| Variable | Default | Description |
|----------|---------|-------------|
| `ROBOHASH_IMG_CACHE_SIZE` | 100 | Maximum image cache size in megabytes |

Example:
```bash
# Set cache size to 100MB
export ROBOHASH_IMG_CACHE_SIZE=100
docker run -e ROBOHASH_IMG_CACHE_SIZE=100 -p 8080:8080 ghcr.io/terem42/robohash


## Nginx Configuration

Example production configuration with caching:

```nginx
proxy_cache_path /var/cache/nginx/robohash 
    levels=1:2 
    keys_zone=robohash_cache:10m
    inactive=1y
    max_size=1g;

server {
    location / {
        proxy_pass http://localhost:8080;
        proxy_cache robohash_cache;
        proxy_cache_valid 200 1y;
        proxy_cache_use_stale error timeout updating;
        add_header X-Cache-Status $upstream_cache_status;
    }
}
```

## Deployment

1. **Standalone binary with embedded resources**:
   ```bash
   go build -o robohash-go ./cmd/server
   ./robohash-go
   ```

2. **Docker**:
   ```bash
   docker build -t ghcr.io/terem42/robohash .
   docker run -p 8080:8080 ghcr.io/terem42/robohash
   ```

3. **Kubernetes**:
   ```yaml
   # Sample deployment.yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: robohash
   spec:
     replicas: 3
     template:
       spec:
         containers:
         - name: robohash
           image: ghcr.io/terem42/robohash
           ports:
           - containerPort: 8080
   ```

## Credits

This project uses the original image assets from [Robohash](https://github.com/e1ven/Robohash) by Colin Davis (e1ven), available under the MIT License.

## License

MIT Â© Andrey Prokopenko
```
---------------------
#!/bin/bash

if ! command -v podman &> /dev/null; then
    echo "âŒ Podman is not installed."
    echo "Please install it with command:"
    echo "  sudo apt-get update && sudo apt-get install podman"
    exit 1
else
    echo "âœ… Podman installed: $(podman --version)"
fi

workdir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

set -x

cd "$workdir" || exit 1

build_version=$(git describe --tags --always 2>/dev/null || echo "v0.0.1")

rm -rf app-bin/*

podman build --format=docker --build-arg BUILD_VERSION="$build_version" \
  -t "ghcr.io/terem42/robohash:$build_version" .
---------------------
#!/bin/bash
find . -type f \( -name "*.go" -o -name "go.*" -o -name "Dockerfile" -o -name "*.sh" -o -name "README.md" \) -print0 | xargs -0 -I{} sh -c 'cat "{}"; echo "---------------------"' > project_sources.txt
echo "--------------------------" >> ./project_sources.txt
tree -d ./assets >> ./project_sources.txt

---------------------
package robohash

import (
	"crypto/sha512"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/davidbyttow/govips/v2/vips"
	"github.com/facette/natsort"
)

var assetsDir = "assets"

var imageCache = NewImageCache() // Cache for decoded images

func init() {
	// ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° vips Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚Ğ¸
	vips.Startup(&vips.Config{
		ConcurrencyLevel: 0, // 0 = Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²
		MaxCacheFiles:    100,
		MaxCacheMem:      50 * 1024 * 1024, // 50MB cache
		MaxCacheSize:     200,
		ReportLeaks:      false,
		CacheTrace:       false,
		CollectStats:     false,
	})
}

type RoboHash struct {
	Text  string
	Set   string
	Size  string
	BGSet string
}

func NewRoboHash(text string, set string) *RoboHash {
	return &RoboHash{
		Text:  text,
		Set:   set,
		Size:  "300x300",
		BGSet: "",
	}
}

func (r *RoboHash) Generate() (*vips.ImageRef, error) {
	if r.Set == "" {
		r.Set = "set1"
	}

	sha512 := sha512.New()
	sha512.Write([]byte(r.Text))
	hashBytes := sha512.Sum(nil)
	hashString := hex.EncodeToString(hashBytes)

	hashParts := splitHashIntoParts(hashString, 11)

	if r.Set == "any" {
		sets, err := os.ReadDir(filepath.Join(assetsDir))
		if err != nil {
			return nil, fmt.Errorf("failed to read sets directory: %v", err)
		}

		var availableSets []string
		for _, entry := range sets {
			if entry.IsDir() && strings.HasPrefix(entry.Name(), "set") {
				availableSets = append(availableSets, entry.Name())
			}
		}

		if len(availableSets) == 0 {
			return nil, fmt.Errorf("no valid sets found")
		}

		setIndex := hexToInt(hashParts[1]) % len(availableSets)
		r.Set = availableSets[setIndex]
	}

	parts := make(map[string]string)

	switch r.Set {
	case "set1":
		entries, err := os.ReadDir(filepath.Join(assetsDir, r.Set))
		if err != nil {
			return nil, fmt.Errorf("failed to read set1 directory: %v", err)
		}

		var colorDirs []string
		for _, entry := range entries {
			if entry.IsDir() {
				colorDirs = append(colorDirs, filepath.Join(r.Set, entry.Name()))
			}
		}

		colorIndex := hexToInt(hashParts[0]) % len(colorDirs)
		colorPath := colorDirs[colorIndex]
		color := filepath.Base(colorPath)

		parts["mouth"] = selectPart(hashParts[4], filepath.Join(r.Set, color, "000#Mouth"))
		parts["eyes"] = selectPart(hashParts[5], filepath.Join(r.Set, color, "001#Eyes"))
		parts["accessory"] = selectPart(hashParts[6], filepath.Join(r.Set, color, "002#Accessory"))
		parts["body"] = selectPart(hashParts[7], filepath.Join(r.Set, color, "003#01Body"))
		parts["face"] = selectPart(hashParts[8], filepath.Join(r.Set, color, "004#02Face"))

	case "set2":
		parts["body"] = selectPart(hashParts[4], filepath.Join(r.Set, "000#04Body"))
		parts["mouth"] = selectPart(hashParts[5], filepath.Join(r.Set, "001#Mouth"))
		parts["eyes"] = selectPart(hashParts[6], filepath.Join(r.Set, "002#Eyes"))
		parts["bodycolors"] = selectPart(hashParts[7], filepath.Join(r.Set, "003#02BodyColors"))
		parts["facecolors"] = selectPart(hashParts[8], filepath.Join(r.Set, "004#01FaceColors"))
		parts["nose"] = selectPart(hashParts[9], filepath.Join(r.Set, "005#Nose"))
		parts["face"] = selectPart(hashParts[10], filepath.Join(r.Set, "006#03Faces"))

	case "set3":
		parts["mouth"] = selectPart(hashParts[4], filepath.Join(r.Set, "000#07Mouth"))
		parts["wave"] = selectPart(hashParts[5], filepath.Join(r.Set, "001#02Wave"))
		parts["eyebrows"] = selectPart(hashParts[6], filepath.Join(r.Set, "002#05Eyebrows"))
		parts["eyes"] = selectPart(hashParts[7], filepath.Join(r.Set, "003#04Eyes"))
		parts["nose"] = selectPart(hashParts[8], filepath.Join(r.Set, "004#06Nose"))
		parts["base"] = selectPart(hashParts[9], filepath.Join(r.Set, "005#01BaseFace"))
		parts["antenna"] = selectPart(hashParts[10], filepath.Join(r.Set, "006#03Antenna"))

	case "set4":
		parts["body"] = selectPart(hashParts[4], filepath.Join(r.Set, "000#00body"))
		parts["fur"] = selectPart(hashParts[5], filepath.Join(r.Set, "001#01fur"))
		parts["eyes"] = selectPart(hashParts[6], filepath.Join(r.Set, "002#02eyes"))
		parts["mouth"] = selectPart(hashParts[7], filepath.Join(r.Set, "003#03mouth"))
		parts["accessory"] = selectPart(hashParts[8], filepath.Join(r.Set, "004#04accessories"))

	case "set5":
		parts["body"] = selectPart(hashParts[4], filepath.Join(r.Set, "000#Body"))
		parts["eyes"] = selectPart(hashParts[5], filepath.Join(r.Set, "001#Eye"))
		parts["eyebrow"] = selectPart(hashParts[6], filepath.Join(r.Set, "002#Eyebrow"))
		parts["mouth"] = selectPart(hashParts[7], filepath.Join(r.Set, "003#Mouth"))
		parts["cloth"] = selectPart(hashParts[8], filepath.Join(r.Set, "004#Cloth"))
		parts["facialhair"] = selectPart(hashParts[9], filepath.Join(r.Set, "005#FacialHair"))
		parts["top"] = selectPart(hashParts[10], filepath.Join(r.Set, "006#Top"))
		parts["accessories"] = selectPart(hashParts[11], filepath.Join(r.Set, "007#Accessories"))

	default:
		return nil, fmt.Errorf("unknown set: %s", r.Set)
	}

	bgSetHash := hashParts[3]
	if r.BGSet == "any" {
		bgSets, err := os.ReadDir(filepath.Join(assetsDir, "backgrounds"))
		if err != nil {
			return nil, fmt.Errorf("failed to read backgrounds directory: %v", err)
		}
		bgSetIndex := hexToInt(bgSetHash) % len(bgSets)
		r.BGSet = bgSets[bgSetIndex].Name()
	}

	return composeImage(parts, r.Size, r.BGSet, r.Set, hashString[0:12])
}

func selectPart(hashPart string, partPath string) string {
	dirPath := filepath.Join(assetsDir, partPath)

	entries, err := os.ReadDir(dirPath)
	if err != nil {
		log.Printf("Error reading directory %s: %v", dirPath, err)
		return ""
	}

	var matches []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".png") {
			fullPath := filepath.Join(dirPath, entry.Name())
			matches = append(matches, fullPath)
		}
	}

	natsort.Sort(matches)

	if len(matches) == 0 {
		log.Printf("No PNG files found in directory: %s", dirPath)
		return ""
	}

	index := hexToInt(hashPart) % len(matches)
	return matches[index]
}

func getSetDimensions(set string) (int, int) {
	switch set {
	case "set1":
		return 300, 300
	case "set2":
		return 350, 350
	case "set3":
		return 1015, 1015
	case "set4", "set5":
		return 1024, 1024
	default:
		return 300, 300
	}
}

// ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ - Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿ĞµÑ€ĞµĞ´ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ°Ğ¼Ğ¸ vips
func normalizeImage(img *vips.ImageRef) error {
	// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
	if img.Interpretation() != vips.InterpretationSRGB {
		if err := img.ToColorSpace(vips.InterpretationSRGB); err != nil {
			return fmt.Errorf("failed to convert to sRGB: %v", err)
		}
	}

	// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ² Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
	bands := img.Bands()
	if bands == 3 {
		if err := img.AddAlpha(); err != nil {
			return fmt.Errorf("failed to add alpha channel: %v", err)
		}
	} else if bands != 4 {
		return fmt.Errorf("unexpected number of bands: %d", bands)
	}

	return nil
}

func composeImage(parts map[string]string, size string, bgSet string, set string, bgSetHashPart string) (*vips.ImageRef, error) {
	width, height := getSetDimensions(set)

	// Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ·Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ğ²Ñ‹Ğ·Ğ¾Ğ²
	base, err := vips.Black(width, height)
	if err != nil {
		return nil, fmt.Errorf("failed to create base image: %v", err)
	}

	// ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞµĞ¼ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ° Ğ¸ Ğ°Ğ»ÑŒÑ„Ñ‹
	if err := base.ToColorSpace(vips.InterpretationSRGB); err != nil {
		base.Close()
		return nil, fmt.Errorf("failed to set color space: %v", err)
	}

	if err := base.AddAlpha(); err != nil {
		base.Close()
		return nil, fmt.Errorf("failed to add alpha channel: %v", err)
	}

	// Ğ”ĞµĞ»Ğ°ĞµĞ¼ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ñ‹Ğ¼ Ğ¾Ğ´Ğ½Ğ¸Ğ¼ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ¼
	if err := base.Linear([]float64{1, 1, 1, 0}, []float64{0, 0, 0, 0}); err != nil {
		base.Close()
		return nil, fmt.Errorf("failed to make image transparent: %v", err)
	}

	// Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¾Ğ½ ĞµÑĞ»Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ğ½
	if bgSet != "" {
		bgDirPath := filepath.Join(assetsDir, "backgrounds", bgSet)

		entries, err := os.ReadDir(bgDirPath)
		if err != nil {
			log.Printf("Error reading background directory %s: %v", bgDirPath, err)
		} else {
			var bgFiles []string
			for _, entry := range entries {
				if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".png") {
					bgFiles = append(bgFiles, filepath.Join(bgDirPath, entry.Name()))
				}
			}

			if len(bgFiles) > 0 {
				bgIndex := hexToInt(bgSetHashPart) % len(bgFiles)

				bgImg, err := loadAndResizeImage(bgFiles[bgIndex], width, height)
				if err != nil {
					base.Close()
					return nil, fmt.Errorf("error loading background: %v", err)
				}

				// ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·ÑƒĞµĞ¼ Ñ„Ğ¾Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ (Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ)
				if err := normalizeImage(bgImg); err != nil {
					base.Close()
					bgImg.Close()
					return nil, fmt.Errorf("error normalizing background: %v", err)
				}

				// ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¸Ğ½Ğ³ Ñ„Ğ¾Ğ½Ğ°
				if err := base.Composite(bgImg, vips.BlendModeOver, 0, 0); err != nil {
					base.Close()
					bgImg.Close()
					return nil, fmt.Errorf("error compositing background: %v", err)
				}
				bgImg.Close()
			}
		}
	}

	order := getPartsOrder(set)

	for _, partType := range order {
		if partPath, ok := parts[partType]; ok && partPath != "" {
			partImg, err := loadAndResizeImage(partPath, width, height)
			if err != nil {
				log.Printf("Error loading part %s (%s): %v", partType, partPath, err)
				continue
			}

			// ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·ÑƒĞµĞ¼ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ñ‡Ğ°ÑÑ‚Ğ¸ (Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ)
			if err := normalizeImage(partImg); err != nil {
				log.Printf("Error normalizing part %s: %v", partType, err)
				partImg.Close()
				continue
			}

			// ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¸Ğ½Ğ³ Ñ‡Ğ°ÑÑ‚Ğ¸
			if err := base.Composite(partImg, vips.BlendModeOver, 0, 0); err != nil {
				log.Printf("Error compositing part %s: %v", partType, err)
			}
			partImg.Close()
		}
	}

	// Ğ˜Ğ·Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾
	if size != "" {
		sizeParts := strings.Split(size, "x")
		if len(sizeParts) == 2 {
			targetWidth, err1 := strconv.Atoi(sizeParts[0])
			targetHeight, err2 := strconv.Atoi(sizeParts[1])

			if err1 == nil && err2 == nil && (targetWidth != width || targetHeight != height) {
				resized, err := resizeImageOptimized(base, targetWidth, targetHeight)
				if err != nil {
					base.Close()
					return nil, err
				}
				base.Close()
				return resized, nil
			}
		}
	}

	return base, nil
}

func splitHashIntoParts(hash string, count int) []string {
	partLength := len(hash) / count
	parts := make([]string, count)
	for i := 0; i < count; i++ {
		start := i * partLength
		end := (i + 1) * partLength
		parts[i] = hash[start:end]
	}
	parts = append(parts, parts...)
	return parts
}

func hexToInt(hexStr string) int {
	num, err := strconv.ParseInt(hexStr, 16, 64)
	if err != nil {
		return 0
	}
	return int(num)
}

func getPartsOrder(set string) []string {
	switch set {
	case "set1":
		return []string{
			"body",      // 003#01Body
			"face",      // 004#02Face
			"eyes",      // 001#Eyes
			"mouth",     // 000#Mouth
			"accessory", // 002#Accessory
		}

	case "set2":
		return []string{
			"facecolors", // 004#01FaceColors
			"bodycolors", // 003#02BodyColors
			"face",       // 006#03Faces
			"body",       // 000#04Body
			"mouth",      // 001#Mouth
			"eyes",       // 002#Eyes
			"nose",       // 005#Nose
		}

	case "set3":
		return []string{
			"base",     // 005#01BaseFace
			"wave",     // 001#02Wave
			"antenna",  // 006#03Antenna
			"eyes",     // 003#04Eyes
			"eyebrows", // 002#05Eyebrows
			"nose",     // 004#06Nose
			"mouth",    // 000#07Mouth
		}

	case "set4":
		return []string{
			"body",      // 000#00body
			"fur",       // 001#01fur
			"eyes",      // 002#02eyes
			"mouth",     // 003#03mouth
			"accessory", // 004#04accessories
		}

	case "set5":
		return []string{
			"body",        // 000#Body
			"eyes",        // 001#Eye
			"eyebrow",     // 002#Eyebrow
			"mouth",       // 003#Mouth
			"cloth",       // 004#Cloth
			"facialhair",  // 005#FacialHair
			"top",         // 006#Top
			"accessories", // 007#Accessories
		}

	default:
		return []string{
			"body",
			"face",
			"eyes",
			"mouth",
			"accessory",
		}
	}
}

func loadAndResizeImage(path string, width, height int) (*vips.ImageRef, error) {
	resizedKey := fmt.Sprintf("%s|%dx%d", path, width, height)

	// Check if resized version is cached
	if data, ok := imageCache.Get(resizedKey); ok {
		img, err := vips.NewImageFromBuffer(data)
		if err == nil {
			return img, nil
		}
		// If loading from cache failed, continue to reload
	}

	originalKey := fmt.Sprintf("%s|original", path)
	var img *vips.ImageRef

	// Check if original is cached
	if data, ok := imageCache.Get(originalKey); ok {
		var err error
		img, err = vips.NewImageFromBuffer(data)
		if err != nil {
			// If loading from cache failed, reload from file
			img, err = loadImage(path)
			if err != nil {
				return nil, err
			}
		}
	} else {
		// Load from file and cache
		var err error
		img, err = loadImage(path)
		if err != nil {
			return nil, err
		}

		// Export to PNG and cache the raw data
		if pngData, _, err := img.ExportPng(&vips.PngExportParams{Quality: 100}); err == nil {
			imageCache.Set(originalKey, pngData, len(pngData))
		}
	}

	// Check if we need to resize
	if img.Width() == width && img.Height() == height {
		return img, nil
	}

	resizedImg, err := resizeImageOptimized(img, width, height)
	if err != nil {
		img.Close()
		return nil, err
	}
	img.Close()

	if pngData, _, err := resizedImg.ExportPng(&vips.PngExportParams{Quality: 100}); err == nil {
		imageCache.Set(resizedKey, pngData, len(pngData))
	}

	return resizedImg, nil
}

// ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°
func resizeImageOptimized(img *vips.ImageRef, targetWidth, targetHeight int) (*vips.ImageRef, error) {
	currentWidth := img.Width()
	currentHeight := img.Height()

	// Ğ˜Ğ·Ğ±ĞµĞ³Ğ°ĞµĞ¼ Ğ½ĞµĞ½ÑƒĞ¶Ğ½Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ ĞµÑĞ»Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ ÑƒĞ¶Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹
	if currentWidth == targetWidth && currentHeight == targetHeight {
		return img, nil
	}

	// Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ± Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ·
	scale := float64(targetWidth) / float64(currentWidth)

	// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ²Ñ‹ÑĞ¾ĞºĞ¾ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°
	if err := img.Resize(scale, vips.KernelLanczos3); err != nil {
		return nil, fmt.Errorf("failed to resize image: %v", err)
	}

	// ĞĞ±Ñ€ĞµĞ·Ğ°ĞµĞ¼ Ğ´Ğ¾ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
	newHeight := img.Height()
	if newHeight != targetHeight {
		if err := img.ExtractArea(0, 0, targetWidth, targetHeight); err != nil {
			return nil, fmt.Errorf("failed to extract area: %v", err)
		}
	}

	return img, nil
}

func loadImage(path string) (*vips.ImageRef, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ» Ğ² Ğ±ÑƒÑ„ĞµÑ€
	buf := make([]byte, 0)
	chunk := make([]byte, 1024)
	for {
		n, err := file.Read(chunk)
		if n > 0 {
			buf = append(buf, chunk[:n]...)
		}
		if err != nil {
			break
		}
	}

	// Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· Ğ±ÑƒÑ„ĞµÑ€Ğ°
	img, err := vips.NewImageFromBuffer(buf)
	if err != nil {
		return nil, fmt.Errorf("failed to load image from buffer: %v", err)
	}

	return img, nil
}
---------------------
package robohash

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"runtime"
	"testing"

	"github.com/davidbyttow/govips/v2/vips"
)

type testCase struct {
	name          string
	text          string
	set           string
	size          string
	bgSet         string
	png_expected  string
	avif_expected string
	webp_expected string
}

func setupTests() {
	assetsDir = "../assets"
	// Lock OS thread as vips is not goroutine-safe during initialization
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	cfg := &vips.Config{
		ConcurrencyLevel: 1, // Use 1 thread for tests to avoid race conditions
		MaxCacheFiles:    0,
		MaxCacheMem:      0,
		MaxCacheSize:     0,
		ReportLeaks:      true,
		CacheTrace:       true,
	}
	vips.Startup(cfg)

}

func TestRoboHashGeneration(t *testing.T) {
	tests := []testCase{
		{
			name:          "Default set1 with simple text",
			text:          "test123",
			set:           "set1",
			size:          "300x300",
			bgSet:         "",
			png_expected:  "0d387613c5e8906ead77f9c721f72605",
			avif_expected: "5654cc45d232fb18550f79785fd2a40b",
			webp_expected: "c2c07051e15d01fe90a86c287503915f",
		},
		{
			name:          "set2 with different text",
			text:          "another_test",
			set:           "set2",
			size:          "350x350",
			bgSet:         "",
			png_expected:  "90bec5f6836c11aebf9655af401910d2",
			avif_expected: "bc1b9a1066bdfe8ec2fa71b9fefa7f5e",
			webp_expected: "2d097c23f664b8df7452f4d685368860",
		},
		{
			name:          "set3 with background",
			text:          "complex_robot",
			set:           "set3",
			size:          "500x500",
			bgSet:         "bg1",
			png_expected:  "508d1f14512da60aa3ba9bd93f3937e3",
			avif_expected: "e1e14027059152c8af398881fc11d58b",
			webp_expected: "9bb4a79588921bc4eb3e663d5e84b057",
		},
		{
			name:          "set4 with custom size",
			text:          "cat_avatar",
			set:           "set4",
			size:          "200x200",
			bgSet:         "",
			png_expected:  "7cbc9d0fde39a9644d3322ab93c14106",
			avif_expected: "7975ef5c2b1162c469d22a855d9d051e",
			webp_expected: "51ab01e37530843b1f95ab0f82fc7eac",
		},
		{
			name:          "set5 human avatar",
			text:          "human_user",
			set:           "set5",
			size:          "400x400",
			bgSet:         "bg2",
			png_expected:  "997f188de3228e39616b1d154a1f257d",
			avif_expected: "0fbed7170d0f8cb6439e99b9224e7069",
			webp_expected: "5a04bef70337ef4977345a1ce035fd24",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			robo := NewRoboHash(tt.text, tt.set)
			robo.Size = tt.size
			robo.BGSet = tt.bgSet

			img, err := robo.Generate()
			if err != nil {
				t.Fatalf("Generate() failed: %v", err)
			}
			if img == nil {
				t.Fatal("Generate() returned nil image")
			}
			defer img.Close() // Important: close vips image to prevent memory leaks

			// Test PNG encoding
			pngBuf, _, err := img.ExportPng(&vips.PngExportParams{
				Quality: 100,
			})
			if err != nil {
				t.Fatalf("PNG export failed: %v", err)
			}
			imgHash := md5Hash(pngBuf)
			if imgHash != tt.png_expected {
				t.Errorf("PNG hash mismatch: got %s, want %s", imgHash, tt.png_expected)
			}

			// Test AVIF encoding
			avifBuf, _, err := img.ExportAvif(&vips.AvifExportParams{
				Quality: 100,
			})
			if err != nil {
				t.Fatalf("AVIF export failed: %v", err)
			}
			imgHash = md5Hash(avifBuf)
			if imgHash != tt.avif_expected {
				t.Errorf("AVIF hash mismatch: got %s, want %s", imgHash, tt.avif_expected)
			}

			// Test WebP encoding
			webpBuf, _, err := img.ExportWebp(&vips.WebpExportParams{
				Quality:  100,
				Lossless: true,
			})
			if err != nil {
				t.Fatalf("WEBP export failed: %v", err)
			}
			imgHash = md5Hash(webpBuf)
			if imgHash != tt.webp_expected {
				t.Errorf("WEBP hash mismatch: got %s, want %s", imgHash, tt.webp_expected)
			}
		})
	}
}

func TestEmptyText(t *testing.T) {
	setupTests()
	robo := NewRoboHash("", "set1")
	img, err := robo.Generate()
	if err != nil {
		t.Fatalf("Generate() with empty text failed: %v", err)
	}
	if img == nil {
		t.Error("Generated image is nil for empty text")
	} else {
		defer img.Close()
	}
}

func TestInvalidSet(t *testing.T) {
	setupTests()
	robo := NewRoboHash("test", "invalid_set")
	img, err := robo.Generate()
	if err == nil {
		t.Error("Expected error for invalid set, got nil")
		if img != nil {
			img.Close()
		}
	}
}

func TestAnySet(t *testing.T) {
	setupTests()
	robo := NewRoboHash("test_any", "any")
	img, err := robo.Generate()
	if err != nil {
		t.Fatalf("Generate() with 'any' set failed: %v", err)
	}
	if img == nil {
		t.Error("Generated image is nil for 'any' set")
	} else {
		defer img.Close()

		// Verify image has expected dimensions (should be one of the set dimensions)
		width := img.Width()
		height := img.Height()

		validSizes := [][2]int{
			{300, 300},   // set1
			{350, 350},   // set2
			{1015, 1015}, // set3
			{1024, 1024}, // set4, set5
		}

		found := false
		for _, size := range validSizes {
			if width == size[0] && height == size[1] {
				found = true
				break
			}
		}

		if !found {
			t.Errorf("Unexpected image dimensions for 'any' set: %dx%d", width, height)
		}
	}
}

func TestBackgroundAny(t *testing.T) {
	setupTests()
	robo := NewRoboHash("test_bg", "set1")
	robo.BGSet = "any"

	img, err := robo.Generate()
	if err != nil {
		t.Fatalf("Generate() with 'any' background failed: %v", err)
	}
	if img == nil {
		t.Error("Generated image is nil for 'any' background")
	} else {
		defer img.Close()
	}
}

func TestDifferentSizes(t *testing.T) {
	sizes := []string{"100x100", "200x200", "400x400", "800x800"}

	for _, size := range sizes {
		t.Run("Size_"+size, func(t *testing.T) {
			robo := NewRoboHash("test_size", "set1")
			robo.Size = size

			img, err := robo.Generate()
			if err != nil {
				t.Fatalf("Generate() with size %s failed: %v", size, err)
			}
			if img == nil {
				t.Error("Generated image is nil")
				return
			}
			defer img.Close()

			// Parse expected dimensions
			var expectedWidth, expectedHeight int
			if _, err := fmt.Sscanf(size, "%dx%d", &expectedWidth, &expectedHeight); err != nil {
				t.Fatalf("Failed to parse size %s: %v", size, err)
			}

			// Check actual dimensions
			if img.Width() != expectedWidth || img.Height() != expectedHeight {
				t.Errorf("Size mismatch: expected %dx%d, got %dx%d",
					expectedWidth, expectedHeight, img.Width(), img.Height())
			}
		})
	}
}

func TestConsistency(t *testing.T) {
	setupTests()
	// Test that the same input always produces the same output
	text := "consistency_test"
	set := "set1"

	robo1 := NewRoboHash(text, set)
	img1, err := robo1.Generate()
	if err != nil {
		t.Fatalf("First generation failed: %v", err)
	}
	defer img1.Close()

	robo2 := NewRoboHash(text, set)
	img2, err := robo2.Generate()
	if err != nil {
		t.Fatalf("Second generation failed: %v", err)
	}
	defer img2.Close()

	// Export both images as PNG and compare
	png1, _, err := img1.ExportPng(&vips.PngExportParams{Quality: 100})
	if err != nil {
		t.Fatalf("Failed to export first image: %v", err)
	}

	png2, _, err := img2.ExportPng(&vips.PngExportParams{Quality: 100})
	if err != nil {
		t.Fatalf("Failed to export second image: %v", err)
	}

	hash1 := md5Hash(png1)
	hash2 := md5Hash(png2)

	if hash1 != hash2 {
		t.Errorf("Images are not consistent: hash1=%s, hash2=%s", hash1, hash2)
	}
}

func TestAllSets(t *testing.T) {
	sets := []string{"set1", "set2", "set3", "set4", "set5"}

	for _, set := range sets {
		t.Run("Set_"+set, func(t *testing.T) {
			robo := NewRoboHash("test_"+set, set)
			img, err := robo.Generate()
			if err != nil {
				t.Fatalf("Generate() for %s failed: %v", set, err)
			}
			if img == nil {
				t.Errorf("Generated image is nil for set %s", set)
				return
			}
			defer img.Close()

			// Verify image has expected dimensions for each set
			expectedWidth, expectedHeight := getSetDimensions(set)
			if img.Width() != expectedWidth || img.Height() != expectedHeight {
				t.Errorf("Wrong dimensions for %s: expected %dx%d, got %dx%d",
					set, expectedWidth, expectedHeight, img.Width(), img.Height())
			}
		})
	}
}

// Benchmark tests
func BenchmarkGenerate(b *testing.B) {
	robo := NewRoboHash("benchmark_test", "set1")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		img, err := robo.Generate()
		if err != nil {
			b.Fatalf("Generate failed: %v", err)
		}
		if img != nil {
			img.Close()
		}
	}
}

func BenchmarkGenerateWithResize(b *testing.B) {
	robo := NewRoboHash("benchmark_resize", "set1")
	robo.Size = "512x512"

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		img, err := robo.Generate()
		if err != nil {
			b.Fatalf("Generate failed: %v", err)
		}
		if img != nil {
			img.Close()
		}
	}
}

func BenchmarkGenerateWithBackground(b *testing.B) {
	robo := NewRoboHash("benchmark_bg", "set1")
	robo.BGSet = "bg1"

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		img, err := robo.Generate()
		if err != nil {
			b.Fatalf("Generate failed: %v", err)
		}
		if img != nil {
			img.Close()
		}
	}
}

func md5Hash(data []byte) string {
	hasher := md5.New()
	hasher.Write(data)
	return hex.EncodeToString(hasher.Sum(nil))
}
---------------------
package robohash

import (
	"container/list"
	"os"
	"strconv"
	"sync"

	"github.com/cespare/xxhash/v2"
)

const (
	shardSizeMB   = 10
	minShardCount = 4
)

type cacheItem struct {
	key  string
	img  []byte
	size int
}

type ShardedImageCache struct {
	shards []*imageCacheShard
}

type imageCacheShard struct {
	mu          sync.RWMutex
	list        *list.List
	items       map[string]*list.Element
	currentSize int
	maxSize     int
}

func NewImageCache() *ShardedImageCache {
	maxSizeMB := getCacheSizeMB()
	shardCount := calculateShardCount(maxSizeMB)

	shards := make([]*imageCacheShard, shardCount)
	for i := range shards {
		shards[i] = &imageCacheShard{
			list:    list.New(),
			items:   make(map[string]*list.Element),
			maxSize: (maxSizeMB * 1024 * 1024) / shardCount,
		}
	}

	return &ShardedImageCache{
		shards: shards,
	}
}

func calculateShardCount(maxSizeMB int) int {
	shardCount := maxSizeMB / shardSizeMB
	if shardCount < minShardCount {
		return minShardCount
	}
	return shardCount
}

func getCacheSizeMB() int {
	if sizeStr := os.Getenv("ROBOHASH_IMG_CACHE_SIZE"); sizeStr != "" {
		if size, err := strconv.Atoi(sizeStr); err == nil && size > 0 {
			return size
		}
	}
	return 100 // Default size 100MB
}

func (c *ShardedImageCache) getShard(key string) *imageCacheShard {
	hash := xxhash.Sum64String(key)
	return c.shards[hash%uint64(len(c.shards))]
}

func (c *ShardedImageCache) Get(key string) ([]byte, bool) {
	shard := c.getShard(key)
	shard.mu.RLock()
	defer shard.mu.RUnlock()

	if elem, ok := shard.items[key]; ok {
		shard.list.MoveToFront(elem)
		// Return a copy of the image data
		imgCopy := make([]byte, len(elem.Value.(*cacheItem).img))
		copy(imgCopy, elem.Value.(*cacheItem).img)
		return imgCopy, true
	}
	return nil, false
}

func (c *ShardedImageCache) Set(key string, img []byte, imgSize int) {
	shard := c.getShard(key)
	shard.mu.Lock()
	defer shard.mu.Unlock()

	// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ÑƒĞ¶Ğµ Ñ‚Ğ°ĞºĞ¾Ğ¹ ĞºĞ»ÑÑ‡
	if elem, ok := shard.items[key]; ok {
		oldItem := elem.Value.(*cacheItem)
		oldSize := oldItem.size

		oldItem.img = img
		oldItem.size = imgSize
		shard.currentSize += imgSize - oldSize
		shard.list.MoveToFront(elem)
		return
	}

	// ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ Ğ¼ĞµÑÑ‚Ğ¾ ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
	for shard.currentSize+imgSize > shard.maxSize && shard.list.Len() > 0 {
		oldest := shard.list.Back()
		oldestItem := oldest.Value.(*cacheItem)

		shard.list.Remove(oldest)
		delete(shard.items, oldestItem.key)
		shard.currentSize -= oldestItem.size
	}

	// Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ
	item := &cacheItem{
		key:  key,
		img:  img,
		size: imgSize,
	}
	elem := shard.list.PushFront(item)
	shard.items[key] = elem
	shard.currentSize += imgSize
}

// Cleanup Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ² ĞºĞµÑˆĞµ Ğ¸ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµÑ‚ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ
func (c *ShardedImageCache) Cleanup() {
	for _, shard := range c.shards {
		shard.mu.Lock()
		shard.items = make(map[string]*list.Element)
		shard.list.Init()
		shard.currentSize = 0
		shard.mu.Unlock()
	}
}
---------------------
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"
	"net/http"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/davidbyttow/govips/v2/vips"
	"github.com/terem42/robohash/robohash"
)

var buildVersion = "HEAD"

func generateETag(data []byte) string {
	hash := sha256.Sum256(data)
	return hex.EncodeToString(hash[:])
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"status": "ok", "version": "` + buildVersion + `", "timestamp": "` + time.Now().UTC().Format(time.RFC3339) + `"}`))
}

func hashHandler(w http.ResponseWriter, r *http.Request) {

	path := strings.TrimPrefix(r.URL.Path, "/")
	ext := filepath.Ext(path)
	text := strings.TrimSuffix(path, filepath.Ext(path))

	if strings.HasPrefix(path, "favicon") {
		http.NotFound(w, r)
		return
	}

	if text == "" {
		text = "example"
	}

	query := r.URL.Query()
	roboHash := robohash.RoboHash{
		Text:  text,
		Set:   query.Get("set"),
		Size:  query.Get("size"),
		BGSet: query.Get("bgset"),
	}

	img, err := roboHash.Generate()
	if err != nil {
		http.Error(w, fmt.Sprintf("Error generating image: %v", err), http.StatusInternalServerError)
		return
	}
	defer img.Close()

	var imgBuf []byte
	var contentType string

	switch strings.ToLower(ext) {
	case ".avif":
		// Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ² AVIF
		imgBuf, _, err = img.ExportAvif(&vips.AvifExportParams{
			Quality:  85,    // ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑĞ¶Ğ°Ñ‚Ğ¸Ñ
			Speed:    8,     // Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ (0-8, Ğ±Ğ¾Ğ»ÑŒÑˆĞµ = Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ Ğ½Ğ¾ Ñ…ÑƒĞ¶Ğµ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾)
			Lossless: false, // Ğ¡Ğ¶Ğ°Ñ‚Ğ¸Ğµ Ñ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ¼Ğ¸
		})
		if err != nil {
			http.Error(w, fmt.Sprintf("Error encoding AVIF image: %v", err), http.StatusInternalServerError)
			return
		}
		contentType = "image/avif"

	case ".webp":
		// Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ² WebP
		imgBuf, _, err = img.ExportWebp(&vips.WebpExportParams{
			Quality:         85,   // ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ»Ñ lossy
			Lossless:        true, // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ lossless Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ³Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°
			NearLossless:    false,
			ReductionEffort: 4, // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ (0-6)
		})
		if err != nil {
			http.Error(w, fmt.Sprintf("Error encoding WEBP image: %v", err), http.StatusInternalServerError)
			return
		}
		contentType = "image/webp"

	case ".jpg", ".jpeg":
		// Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ² JPEG
		imgBuf, _, err = img.ExportJpeg(&vips.JpegExportParams{
			Quality:        85,
			Interlace:      false,
			OptimizeCoding: true,
			SubsampleMode:  vips.VipsForeignSubsampleAuto,
		})
		if err != nil {
			http.Error(w, fmt.Sprintf("Error encoding JPEG image: %v", err), http.StatusInternalServerError)
			return
		}
		contentType = "image/jpeg"

	default:
		// Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ² PNG (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ)
		imgBuf, _, err = img.ExportPng(&vips.PngExportParams{
			Compression: 6,     // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ ÑĞ¶Ğ°Ñ‚Ğ¸Ñ PNG (0-9)
			Interlace:   false, // ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑÑĞ¸Ğ²Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°
			Quality:     85,    // ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ (Ğ´Ğ»Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ¾Ğ²Ñ‹Ñ… Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹)
		})
		if err != nil {
			http.Error(w, fmt.Sprintf("Error encoding PNG image: %v", err), http.StatusInternalServerError)
			return
		}
		contentType = "image/png"
	}

	// Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
	w.Header().Set("Content-Type", contentType)
	w.Header().Set("Cache-Control", "public, max-age=31536000")
	w.Header().Set("Content-Length", strconv.Itoa(len(imgBuf)))
	w.Header().Set("ETag", `"`+generateETag(imgBuf)+`"`)
	w.Header().Set("Last-Modified", time.Now().UTC().Format(http.TimeFormat))
	w.Write(imgBuf)

}

func main() {
	log.Printf("Robohash Go version %s", buildVersion)
	http.HandleFunc("/health", healthHandler)
	http.HandleFunc("/", hashHandler)
	fmt.Println("Server running on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
---------------------
module github.com/terem42/robohash

go 1.23.4

require (
	github.com/cespare/xxhash/v2 v2.3.0
	github.com/davidbyttow/govips/v2 v2.16.0
	github.com/facette/natsort v0.0.0-20181210072756-2cd4dd1e2dcb
)

require (
	golang.org/x/image v0.27.0 // indirect
	golang.org/x/net v0.25.0 // indirect
	golang.org/x/text v0.25.0 // indirect
)
---------------------
--------------------------
./assets
â”œâ”€â”€ backgrounds
â”‚Â Â  â”œâ”€â”€ bg1
â”‚Â Â  â””â”€â”€ bg2
â”œâ”€â”€ set1
â”‚Â Â  â”œâ”€â”€ blue
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ brown
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ green
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ grey
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ orange
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ pink
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ purple
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ red
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â”œâ”€â”€ white
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 000#Mouth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 001#Eyes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 002#Accessory
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 003#01Body
â”‚Â Â  â”‚Â Â  â””â”€â”€ 004#02Face
â”‚Â Â  â””â”€â”€ yellow
â”‚Â Â      â”œâ”€â”€ 000#Mouth
â”‚Â Â      â”œâ”€â”€ 001#Eyes
â”‚Â Â      â”œâ”€â”€ 002#Accessory
â”‚Â Â      â”œâ”€â”€ 003#01Body
â”‚Â Â      â””â”€â”€ 004#02Face
â”œâ”€â”€ set2
â”‚Â Â  â”œâ”€â”€ 000#04Body
â”‚Â Â  â”œâ”€â”€ 001#Mouth
â”‚Â Â  â”œâ”€â”€ 002#Eyes
â”‚Â Â  â”œâ”€â”€ 003#02BodyColors
â”‚Â Â  â”œâ”€â”€ 004#01FaceColors
â”‚Â Â  â”œâ”€â”€ 005#Nose
â”‚Â Â  â””â”€â”€ 006#03Faces
â”œâ”€â”€ set3
â”‚Â Â  â”œâ”€â”€ 000#07Mouth
â”‚Â Â  â”œâ”€â”€ 001#02Wave
â”‚Â Â  â”œâ”€â”€ 002#05Eyebrows
â”‚Â Â  â”œâ”€â”€ 003#04Eyes
â”‚Â Â  â”œâ”€â”€ 004#06Nose
â”‚Â Â  â”œâ”€â”€ 005#01BaseFace
â”‚Â Â  â””â”€â”€ 006#03Antenna
â”œâ”€â”€ set4
â”‚Â Â  â”œâ”€â”€ 000#00body
â”‚Â Â  â”œâ”€â”€ 001#01fur
â”‚Â Â  â”œâ”€â”€ 002#02eyes
â”‚Â Â  â”œâ”€â”€ 003#03mouth
â”‚Â Â  â””â”€â”€ 004#04accessories
â””â”€â”€ set5
    â”œâ”€â”€ 000#Body
    â”œâ”€â”€ 001#Eye
    â”œâ”€â”€ 002#Eyebrow
    â”œâ”€â”€ 003#Mouth
    â”œâ”€â”€ 004#Cloth
    â”œâ”€â”€ 005#FacialHair
    â”œâ”€â”€ 006#Top
    â””â”€â”€ 007#Accessories

96 directories
